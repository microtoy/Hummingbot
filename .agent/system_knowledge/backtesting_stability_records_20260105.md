# 回测系统稳定性与 API 一致性修复记录 (2026-01-05)

## 1. 核心问题概述
在进行大规模策略搜索（AWFO）时，发现 `Single`, `Batch`, 以及 `Turbo` 三个回测接口存在结果不一致的问题，且伴随非确定性的“0 交易”异常。

## 2. 已解决的关键 Bug

### A. 批量模式数据竞争 (Race Condition)
*   **问题**：多进程环境下，工作进程同时读写 K 线缓存文件导致冲突。
*   **解决方案**：
    *   引入**原子化文件操作**：使用临时文件写入并执行 `rename`。
    *   **预镜像机制 (Pre-mirroring)**：在主进程启动负载前，预先将挂载卷数据同步至 `/tmp/hbot_data`。
    *   **数据隔离**：确保每个工作进程拥有独立的引擎实例，并在每次执行前显式刷新缓存。

### B. 市场数据准备逻辑错误 (Data Alignment)
*   **问题**：`prepare_market_data` 在合并特征和价格数据时，由于使用索引对齐而非显式时间戳，导致 1m 与 1h 级别的数据在非对齐点无法匹配。
*   **解决方案**：
    *   重构对齐逻辑，强制将 `timestamp` 转换为 `float`。
    *   使用 `pd.merge_asof(direction='backward')` 确保任何时间点的信号都能正确映射到最近的 K 线。

### C. 序列化性能瓶颈 (Serialization Hang)
*   **问题**：回测跨度较长时，JSON 响应体包含数十万个 `ExecutorInfo` 对象，导致 Pydantic 序列化耗时过长，API 超时并返回空响应。
*   **解决方案**：
    *   **Payload 优化**：在批量回测中默认仅返回 `results` 摘要，剥离庞大的执行器详情。
    *   **大对象限流**：单次回测接口限制返回执行器数量上限为 1000，防止内存溢出。

### D. 深度递归崩溃 (RecursionError)
*   **问题**：`floatify` 函数在处理嵌套 Pydantic 配置模型时，由于属性相互引用或深度过大导致栈溢出。
*   **解决方案**：实现**递归安全版 `floatify`**，包含 `seen` 集合记录对象标识及 20 层的硬深度限制。

## 3. 验证标准 (Parity Check)
系统现在要求在以下压力测试下保持 100% 一致性：
*   **Token**: LINK-USDT / SOL-USDT
*   **周期**: 1个月至3个月
*   **并发**: 10+ 进程
*   **结果**: PnL 精度达 10^-6，交易次数完全相同。

## 4. 维护建议
*   修改 `backtesting_engine_base.py` 时，务必通过 `ComplexCompare.py` 进行跨接口对齐验证。
*   严禁在多进程工作环境中使用全局变量存储动态状态。
